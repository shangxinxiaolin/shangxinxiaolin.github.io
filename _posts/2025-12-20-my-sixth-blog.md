---
layout:     post                      # 使用的布局（不需要改）
title:      日概要                    # 标题
subtitle:   今日                      # 副标题
date:       2025-12-20 12:00:00 +0800 # 时间（修正语法）
author:     XL                        # 作者
header-img: img/post-bg-universe.jpg  # 这篇文章标题背景图片
catalog:    true                      # 是否归档
tags:                                 # 标签
    - 生活
    - 大一
---
## 今日

12.20

今天第二更了。主要是今天在更完那个之后，因为蛮晚才出了宿舍（不得不说一定不能呆在宿舍，整个人感觉都会有点萎靡了。），然后本来想着说学学高数，然后再去额，写写高数作业，写写思政什么的，结果又发现把文档扔给ai让他给我讲，结果发现他讲的还挺好的，就看了两节Java的内容

第一节是Java的抽象类和抽象方法。首先正如我们之前所知道的，类是对象的蓝图，那么我们就可以说抽象类就是一张未设计完毕的蓝图，并且将在其子类内以重写的方式将其设计完毕（不错，颇有了几分浪漫色彩）。那么抽象类主要包含以下的几个特点：能够被继承但是无法创建对象、可以有构造器（constructor）、用abstract进行声明、子类必须对其进行重写，否则也必须被声明为abstract、由抽象方法和普通方法组成

能够被继承但是无法创建对象。正因为抽象类能够被继承，所有才能够在子类中被重写，进而去实现一种相当于是代码的复用。抽象类其实也就是相当于是一个模板，在这个模板的基础上我们可以造出好多种不同版本的代码。然后为什么他无法被创建对象呢，因为其中含有未完善的方法，JVM无法知道如何去实现这些方法，因此，就会导致编译报错。不过，虽然我们无法创建抽象类的对象，但是我们仍然可以在子类中对其构造器进行调用，只需要使用super()即可。而上面的讲到的构造类的一个模板的作用，实现了代码的复用，其实也就是Java抽象的一个体现了。

第二个部分讲到的是抽象方法。对它的声明的形式大概是这种：`abstract void method();`而不会包含方法体,即不会包含具体的方法实现，这是我们需要注意的。

抽象方法只能存在于抽象类与接口中。这个很重要。如果一个方法显式地声明为 `abstract` ，那么这个方法必须存在于抽象类中。而接口中的方法如果不是 `default`、`static`或者 `private`方法，那么默认就是一个 `public abstract` 方法。

在这一部分内容中，抽象方法代表一种抽象，而抽象方法被各个子类重写为不同的内容又体现了一种多态。

接下来讲的是接口的内容。如果说抽象类是一张未能设计完毕的蓝图，那么接口便是一张能力清单，告诉你它能够为你提供什么能力。接口主要包含这几个特性：不能创建对象、没有构造器、方法默认是 `public abstract` 、变量默认是 `public static final` 、类通过implements实现接口。

接下来就展开来讲讲接口。首先我们需要明确的一点是，接口本身是不可以使用的，而需要通过类来使用，syntax是 `class classname implements interfacename`。那么接口具有哪些价值所在呢？首先，接口中的抽象方法体现了抽象，然后在实现接口的类中重写接口中的抽象方法就体现了多态，这是它的第一个价值所在。其次，我们之前讲过，继承当中有一个继承多个这种形式的，但是Java的类继承无法实现这种形式。那么我们就有一个办法，因为一个类可以实现多个接口，因此我们就可以通过这种方式来进行实现。与此同时，接口之间也是可以存在继承关系的，即接口也可以被接口所继承，并且一个接口也可以继承多个接口，与此同时，如果一个接口继承了多个接口，然后类又对这个接口进行了实现，那么类就需要完成对他所实现的的接口所继承的所有接口的重写，这样也是实现了一个继承多个的这么一种继承方式。接口实现了多继承，使得一个类具有了多个能力。同时接口为类提供了规范，比如你实现了pology接口，那么你就必须要完成其中的这么一些方法。

接口中的default、private、static方法。在Java8/9之后，接口中引入了这三种方法。第一个default方法引入的原因是假如你定义了一个方法，如果是抽象方法，那么你就需要去重写所有实现了它的类，显然有时候我们并不需要这样做，因此我们可以为其提供这样一种默认的实现。而private无法被接口的外部所访问，只能作为default/private的辅助方法。而static方法我们是可以直接在main方法中通过接口名称直接进行访问的。

大概的内容就是这些了。

